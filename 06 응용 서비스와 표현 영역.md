응용 서비스와 표현 영역
========================
`도메인`과 `리포지토리`를 통해 도메인을 구현하는 방법에 대해서 배웠다.  
그러나, **도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요하다.**      
그리고 이러한 매개체들이 바로 **응용 서비스**와 **표현 영역**이다.      

**표현 영역**  
* 사용자의 요청을 해석한다.    
* 사용자가 어떤 기능을 실행하고 싶어하는지 판별하고 그 기능을 제공하는 응용서비스를 실행한다.   
    
**응용 서비스**        
* 사용자의 요청을 위한 기능을 제공하는 주체다.         
* 기능을 실행하는데 필요한 입력값을 메서드 파라미터로 전달 받고 실행 결과를 리턴한다.     
    
```java
@RequestMapping("/member/join")
public ModelAndView join(HttpServletRequest request) {
    String email = request.getParameter("email");
    String password = request.getParameter("password");
    // 사용자 요청을 응용 서비스에 맞게 변환 
    JoinRequest joinReq = new JoinRequest(email, password);
    // 응용 서비스의 메서드를 호출   
    joinService.join(joinReq);
    ...
}
```

사용자가 원하는 서비스마다의 데이터 형식이 일치하지 않기 때문에        
**표현 영역이 응용 서비스가 요구하는 객체를 생성한 뒤 응용 서비스의 메서드를 호출한다.**         
이후, 응용 서비스로부터 얻은 실행 결과를 사용자에 알맞은 형식으로 응답한다.       

사용자와의 상호작용은 표현 영역이 처리하기에 응용 서비스는 표현 영역에 의존하지 않는다.     
즉, 사용자가 어떠한 방식으로 접근했던지 응용 서비스는 핵심 기능 구현만 신경쓰면 된다.     

# 📗 응용 서비스의 역할 
> 응용 서비스는 사용자가 요청한 기능을 실행한다.    

응용 서비스의 주요 역할은 **도메인 객체를 사용해서 사용자의 요청을 처리하는 것이다.**       
이로인해 표현 영역 입장에서는 **표현 영역과 도메인 영역을 연결해주는 창구 같은 역할이다.**      
        
**응용 서비스는 아래와 같은 작업을 수행한다.**        
* 리포지토리로부터 도메인 객체를 구한다.          
* 도메인 객체를 사용한다.(메서드 호출, 조합등)            

응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기에 아래와 같은 단순한 형태를 갖는다.   
  
```java
public Result doSomeFunc(SomeReq req) {
    SomeAgg agg = someAggRepository.findById(req.getId());
    checkNull(agg);
    agg.doFunc(req.getValue());    
    return createSuccessResult(agg);
}
```
1. 리포지토리에서 애그리거트를 구한다.  
2. 애그리거트의 도메인 기능을 실행한다.    
3. 결과를 리턴한다.   

```java
public Result doSomeCreate(CreateSomeReq req) {
    checkValud(req);
    SomeAgg newAgg = createSome(req);
    somAggRepository.save(newAgg);
    return createSuccessResult(newAgg);
}
```
1. 데이터 중복 등 데이터가 유효한지 검사한다.   
2. 애그리거트를 생성한다.   
3. 리포지토리에 애그리거트를 저장한다.   
4. 결과를 리턴한다.  
  
만약 위와 같은 형태보다 복잡하다면     
**응용 서비스가 도메인 로직을 수행하고 있을 가능성이 높다.(때에 따라 다르지만 안 좋다.)**      
     
응용 서비스는 `도메인 객체 간의 흐름을 제어`외에도         
**도메인의 상태 변경을 트랜잭션으로 처리하는 역할**을 가지고 있다.       

```java
public void blockMembers(String[] blockingIds) {
    if (blockingIds == null || blockingIds.length == 0) return;
    List<Member> members = memberRepository.findByIds(blockingIds);
    for (Member mem : members) {
        mem.block();
    }
}
```  
위와 같은 로직을 처리중에 갑자기 문제가 생긴다면?    
트랜잭션 범위로 설정이 되었다면 롤백을 하겠지만   
그렇지 않은 경우 **일부는 `block()`이 되고 일부는 `block()`이 되지 않아 일관성을 해친다.**     
응용 서비스는 **DB와 맞닿는 부분이기에 트랜잭션 범위로 실행시켜야한다.**        

## 📖 도메인 로직 넣지 않기   
**도메인 로직은 도메인 영역에 위치하고**      
**응용 서비스는 도메인 로직을 구현하지 않는다.**       

```java
public class ChangePasswordService {
    public void changePassword(String memberId, String oldPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        checkMember(member);
        member.changePassword(oldPw, newPw);
      }
}
```
```java
public class Member {
    public void changePassword(String oldPw, String newPw) {
        if (!matchPassword(oldPw)) throw new BadPasswordException();
        setPassword(newPw);
    }

    private boolean matchPassword(String pwd) {
        return passwordEncoder.matchs(pwd);
    }

    private void setPassword(String newPw) {
        if (isEmpty(newPw)) throw new IllegalArgumentException("no new password");
        this.password = newPw;
    }
}
```
기존 암호를 올바르게 입력했는지 여부는 **도메인 자체의 핵심 로직이다.**        
때문에 아래와 같은 코드로 작성을 하면 안 된다.  
   
**안 좋은 사례**
```java
public class ChangePasswordService {
    public void changePassword(String memberId, String oldPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        checkMember(member);
        if (!passwordEncoder.matchs(oldPw, member.getPassword())) {
            throw new BadPasswordException();
        }
        member.setPassword(newPw);
    }
}
```
도메인 로직을 도메인 영역과 응용 서비스에 분산해서 넣으면 코드 품질에 관한 문제들이 발생한다.   
   
* **코드의 응집성이 떨어진다. :** 도메인 로직을 파악하기 위해 여러 영역을 조회 및 분석해야한다.       
* **코드의 중복이 발생한다. :** 여러 서비스에서 동일한 도메인 로직을 구현한다면 유지보수가 힘들어진다.    
   
결과적으로 변경을 어렵게 만든다는 것인데 이는 SW 품질적 가치가 떨어진다는 것을 의미한다.       
SW의 가치를 올리려면 도메인 로직을 도메인 영역에 모으고 중복 발생을 최소화하며 응집도를 높여야한다.     

# 📘 응용 서비스의 구현 
응용 서비스는 **디자인 패턴의 파사드 패턴**과 비슷한 역할을 한다.     
   
## 📖 응용 서비스의 크기   
응용 서비스 구현에 있어 몇 가지 생각할게 있는데 그 중 하나가 **크기**이다.         
`회원` 도메인을 기준으로 응용 서비스는 다음 2가지 방법 중 한가지를 선택한다.   
     
* 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기    
* 구분되는 기능별로 응용 서비스 클래스를 따로 두기     

### 📝 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
```java
public class MemberService {
    private MemberRepository memberRepository;
    
    public void join(MemberJoinRequest joinRequest) { ... }
    public void changePassword(String nenberId, String currentPw, String newPw) { ... }
    public void initializePassword(String memberId) { ... }
    public void leave(String memberId, String curPw) { ... }
    ...
    
}
```
* 중복 로직이 있을경우 private method를 사용하여 중복 로직을 제거할 수 있는 장점이 있다.
* 코드 크기가 커진다는 것은 연관성이 적은 코드가 한 클래스에 함께 위치할 가능성이 높아짐을 의미하는데,   
  이는 결과적으로 관련 없는 코드가 뒤섞여서 코드를 이해하는 데 방해가 될 수 있다.

### 📝 구분되는 기능별로 응용 서비스 클래스를 따로 두기     
```java
public class ChangePasswordService {
    private MemberRepository memberRepository;
    
    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = memberRepository.findById(memberId);
        if (member == null) throw new NoMemberException(memberId);
        member.changePassword(curPw, newPw):
    }
}
```
* 클래스 개수는 많아지지만 이전과 비교해서 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.
* 클래스의 기능이 분산되어 중복해서 동일한 코드를 구현할 가능성이 있다.
  
다만 위 같은 방식으로 코드를 작성할 경우, 여러 클래스에서 중복된 코드가 발생할 수 있다.       
이럴 경우, 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.     

```java
// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현 
public final class MemberServiceHelper {
    public static Member findExistingMember(MemberRepository repo, String memberId) {
        Member member = memberRepository.findById(memberId);
        if (member == null) {
           throw new NoMemberException(memberId); 
        }
        return member;
    }
}
```
```java
// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용 
import static com.myshop.member.application.MemberServiceHelper.*;

public class ChangePasswordService {
    private MemberRepository memberRepositroy;
    
    public void changePassword(String memberId, String curPw, String newPw) {
        Member member = findExistingMember(memberRepository.memberId);
        member.changePassword(curPw, newPw);
    }
    ...
}
```
한 클래스가 여러 역할을 갖는 것보다, 각 클래스마다 구분되는 역할을 갖는 것을 추천한다.      
즉, 한 도메인과 관련된 기능을 하나의 응용 서비스에서 구현하는 방식보다           
구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용한다. -> 다양한 DB를 접할 수 있지 않을까 싶다.     
   
## 📖 응용 서비스의 응용 인터페이스와 클래스     
응용 서비스를 구현할때 주로 논의가 되는 내용 중 하나인 **응용 서비스의 인터페이스 여부다.**    

```java
public class SampleServiceImpl implements SampleService {
    ... // 생략
}
```
그렇다면 생각을 조금 뒤집어서 **인터페이스가 필요한 상황은 언제일까? 🤔**       
인터페이스가 필요한 상황은 몇몇이 있는데 그 중 하나로 **구현 클래스가 여러개인 경우다.**    
그런데, 응용 서비스는 **런타임에 구현체를 교체할 일은 거의 없고 구현 클래스가 2개 이상인 경우도 드물다.**     
  
그렇기 때문에 오히려 소스 파일만 많아지고 전체 구조만 복잡해지는 문제가 발생한다.     
따라서 인터페이스가 명확하게 필요하기 전까지는 응용 서비스의 인터페이스를 이용해서 컨트롤러의 구현을 완성해 나가게 된다.       
  
TDD를 기반으로 개발을 진행했을 때 인터페이스를 이용하는 경우가 종종 있는데      
차라리, Mockito와 같은 테스트용 목 객체를 만들어서 테스트를 하는 것이 보다 나을 것 같다.   

## 📖 메서드 파라미터와 값 리턴    
응용 서비스가 도메인을 흐름을 관리하고 처리하는데는 데이터가 필요하며 이는 표현 영역에서 얻는다.   

```java
public class ChangePasswordService {
    // 암호 변경 기능 구현에 필요한 값을 파라미터로 전달받는다.   
    public void changePassword(String memberId, String curPw, String newPw) {
        ... // 생략 
    }
}
// 또는 
public class ChangePasswordService {
    // 암호 변경 기능 구현에 필요한 값을 파라미터로 전달받는다.   
    public void changePassword(ChangePasswordRequest request) {
        ... // 생략 
    }
}
```
응용 서비스는 파라미터를 통해 각각의 데이터 또는 이들을 묶은 객체를 인자값으로 받아 필요한 기능을 구현한다.   

```java
@Controller
@RequestMapping("/member/changePassword/")
public class MemberPasswordController {
    @Autowired
    private ChangePasswordService changePasswordService;
    
    @RequestMapping(method = RequestMethod.POST)
    public String submit(ChangePasswordRequest changePwdReq) {
        ... // 생략 
    }
}
```
스프링 MVC와 같은 웹 프레임워크는 웹 요청 파라미터를 객체로 변환해주는 기능을 제공하므로      
응용 서비스에 데이터로 전달할 요청 파라미터가 2개 이상 존재하면 데이터 전달을 위한 별도 클래스를 사용하는 것이 편리하다.     

```java
public class OrderService {
    @Transactional
    public OrderNo placeOrder(OrderRequest orderRequest) {
        OrderNo orderNo = orderRepository.nextId();
        Order order = createOrder(orderNo, orderRequest);
        orderRepository.save(order);
        return orderNo;
    }
}
```
표현 영역에서 응용 서비스의 결과가 필요하다면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴받는다.     
단순 리터럴 값일 수도 있고 dto형태의 객체일 수도 있다.           
스프링 MVC(Controller)는 해당 값을 받아 요청에 알맞게 가공을해서 데이터를 전달할 것이다.(뷰/모델/데이터 등등)     
       
응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만             
**도메인 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.**             
이는 **기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.**          
또한, JPA를 사용하는 경우 엔티티 클래스 값의 변경을 초래할 수도 있다.     
         
애그리거트의 상태를 변경하는 응용 서비스가 애그리거트를 리턴할 경우           
해당 애그리거트의 기능을 컨트롤러나 뷰 코드에서 실행하면 안된다는 규칙을 정할 수 있겠지만,        
그보다는 **응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.**        

## 📖 표현 영역에 의존하지 않기       
     
응용 서비스의 **파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안 된다는 점이다.**       

```java
@Controller
@RequesetMapping("/member/changePassword")
public class MemberPasswordController {
    
    @RequestMapping(method = RequestMethod.POST)   
    public String submit(HttpServletRequest request) {
        try {
            // 응용 서비스가 표현 영역에 대한 의존이 발생하면 안 됨!  
            changePasswordService.changePassword(request);
        } catch(NoMemberException ex) {
            // 알맞은 익셉션 처리 및 응답 
        }
    }
    ...
}
```
응용 서비스에서 표현 영역에 대한 의존이 발생하면 **응용 서비스만 단독으로 테스트하기 어려워진다.**      
게다가 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야하는 문제도 발생한다.     





## 트랜잭션 처리  
## 도메인 이벤트 처리  

# 표현 영역 
# 값 검증
# 권한 검사
# 조회 전용 기능과 응용 서비스 


















