# 4개의 영역 
   
### 표현/UI    
사용자의 **요청을 해석해서 응용 서비스에 전달**하고        
응용 서비스의 **결과를 사용자가 이해할 수 있는 형식으로 변환해서 응답**한다.          

**여기서 사용자란? 🤔**   
```
사용자는 웹 브라우저이거나, 
REST API를 이용한 외부 시스템일 수 있다.(모바일, 기타 등등)   
```
       
즉, `HTTP 요청`을 **응용 영역이 필요로 하는 형식으로 변환**해서 응용 영역에 전달하고           
`응용 영역의 응답`을 **HTTP 응답으로 변환해서 전송한다.**(REST 데이터, Model은 전달이 아니기에 뺐습니다.)          
       
쉽게 말하면,       
`@RequestBody`를 이용해서 `사용자`로부터 넘어온 값을 `HTTP 요청 본문에 담긴 값들을 자바 객체로 변환`한 후 `Service`에 넘기고           
`@ResponseBody`를 이용해서 `Servic`로부터 넘어온 값을 `HTTP 응답 본문의 JSON 객체로 변환`한 후 응답하는 것을 말한다.          
즉, `Controller`가 대표적인 예시라고 보면 된다. (MVC라고 책에서는 나왔는데 더 자세히 말하면)        
       
### 응용   
사용자에게 **제공해야 할 기능을 구현한다.**       
`주문 등록`, `주문 취소`, `상품 상세 조회` 등등...      
        
`응용 영역`은 기능을 구현하기 위해 **도메인 영역의 도메인 모델들을 이용한다.**     

```java
public class CancelOrderService {
      
    @Transactional    
    public void cancelOrder(String orderId) {    
        Order order = findOrderById(orderId);     
        if(order == null) throw new OrderNotFoundException(orderId);      
        order.cancel();   
    }
}  
```  
응용 서비스는 로직을 직접 수행하기 보다는        
**도메인 모델에 로직 수행을 위임한다.(역할과 책임, 저는 협력하는 공간으로도 생각합니다.)**           
위 코드도 도메인인 `Order`가 `취소 처리`를 하고 있다.     

### 도메인  
도메인 영역은 **`도메인 모델`을 구현하는 영역**이다.     
`Order`, `OrderLine`, `ShippingInfo` 등등...   
그리고 **`도메인 모델`은 도메인의 핵심 로직을 구현**한다.     
     
**주문 도메인**     
* 배송지 변경    
* 결제 완료        
* 주문 총액 계산    

### 인프라스트럭처
인프라스트럭처 영역은 **구현 기술**에 대한 것을 다룬다.     

* `RDBMS` 연동처리
* [메시징 큐](https://ko.wikipedia.org/wiki/%EB%A9%94%EC%8B%9C%EC%A7%80_%ED%81%90)에 메시지 전송하거나 수신    
* `몽고 DB`, `HBase` 를 사용해서 데이터베이스 연동 처리  
* `SMTP`를 이용한 메일 발송 기능 구현      
* `HTTP 클라이언트`를 이용해서 `REST API`를 호출     
  
인프라스트럭처 영역은      
논리적인 개념을 표현하기 보다는 **실제 구현을 다룬다.**      

`도메인 로직`, `응용 영역`, `표현 영역`은 **구현 기술을 사용한 코드를 직접 만들지는 않는다.**   
대신, **인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.**    
  
예시1)        
1. 응용 영역이 DB에 보관된 데이터가 필요
2. 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어온다.   
       
예시2)       
1. SMTP 연동 모듈을 이용해서 메일 발송    
    
사실 여기서 가장 중요하다고 생각하는 점은 **관심사 분리**이다.      
`도메인 로직`, `응용 영역`, `표현 영역`은 **구현 기술을 어떻게 사용했는지 관심이 없다.**         
오로지 `데이터`만을 필요로 하고 **그 데이터를 잘 가공하는 역할만을 한다.**      
즉, 자신의 역할과 책임 -> `코어 밸류`만을 생각할 뿐이다.      
  
# 계층 구조 아키텍처     
`4 영역`을 구성할 때 많이 사용하는 아키텍처가 아래와 같은 구조이다.   
    
[사진](#)    
  
표현 영역과 응용 영역은 도메인 영역을 사용하고,   
도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조가 적당해보인다.   
도메인 복잡도에 따라 응용과 도메인을 분리하기도 하고     
한 계층으로 합치기도 한다.       

계층 구조는 특성상    
**`상위 계층`에서 `하위 계층`으로의 의존만 존재**하고       
**`하위 계층`은 `상위 계층`에 의존하지 않는다.**     

```java
@Controller
public class SampleController {
    private final SampleService sampleService; // 하위를 의존
    
    public SampleController(SampleService sampleService) {
        this.sampleService = sampleService;
    }
    ... // 
}
```
   
계층 구조를 엄격하게 적용하면        
`상위 계층`은 바로 아래의 `하위 계층`에만 의존해야하지만     
구현의 편리상, **계층 구조를 유연하게 적용할 수 있다.**     
 
즉, `응용 계층`은 바로 아래 계층인 `도메인 계층`에 의존하지만       
**외부 시스템과의 연동을 위해** 더 아래 계층인 `인프라스트럭처 계층`에 의존하기도 한다.          
  
[사진](#)  
  
```java
@Service
public class SampleServiceImpl implements SampleService {
  
    private final SampleRepository sampleRepository; // 도메인이 아닌 인프라스트럭처 영역  
                                                     // 상위 계층에 대한 의존이 없다.  
                                                     
    public SampleServiceImpl(SampleRepository sampleRepository) {
        this.sampleRepository = sampleRepository;
    }
    
    public void findById(Long id) {
        // 여기서 도메인을 얻어온다.   
        Sample sample = sampleRepository.findById(id).orElseThrow(() ->
                new NoSearchSampleByIdException(id));
    }
    
}
```

`응용 영역`과 `도메인 영역`은    
`DB`나 `외부 시스템 연동`을 위해 `인프라스트럭처의 기능`을 사용하므로    
위와 같은 계층 구조를 사용하는 것은 직관적으로 이해하기 쉽다.  
  
하지만, 짚고 넘어갈 부분으로      
`도메인 계층`이 상세한 구현 기술을 다루는 **인프라스트럭처에 종속**된다는 점이다.     
    
도메인의 `가격 계산 규칙`을 예로 들어본다.       
할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것보다       
[룰 엔진](https://javacan.tistory.com/entry/118)을 사용하는 것이 더 알맞을 때가 있다,     
  
> 현재는 룰 엔진을 깊게 다룰 필요는 없다 생각합니다.     
> 다만, 맥락에 대해서만 파악하면 좋을 것 같습니다.   
   
```java
public class CalculateDiscountService {
    private DroolsRuleEngine ruleEngine;
    
    public CalculateDiscountService() {
        ruleEngine = new DroolsRuleEngine();
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId);
        
        MutableMoney money = new MutableMoney(0);
        List<?> facts = Arrays.asList(customer, money);
        facts.addAll(orderLines);
        ruleEngine.evaluate("discountCalculation", facts);
        return money.toImmutableMoney();  
    }
    
}
```
**DroolsRuleEngine**
```java
public class DroolsRuleEngine {
    private KieContainer KContainer;
    
    public DroolsRuleEngine() {
        KieService ks = KieServices.Factory.get();
        KContainer = ks.getKieClasspathContainer();
    }
    
    public void evalute(String sessionName, List<?> facts) {
        KieSession KSession = KContainer.newKieSession(sessionName);
        try {
            facts.forEach(x -> KSession.insert(x));
            KSession.fireAllRules();
        } finally {
            KSession.dispose();
        }
    }
    
}
```

위 코드는 `DroolsRuleEngine`라는 `룰 엔진`을 사용해서 로직을 수행할 수 있는 `인프라스트럭처 영역`의 코드다.           
`evalute()` 메서드를 호출하면 **별도의 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드**라고 생각하면된다.    
     
앞서 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것보다           
[룰 엔진](https://javacan.tistory.com/entry/118)을 사용하는 것이 더 낫다는 식으로 언급했지만  
위 코드는 2개의 큰 문제를 가지고 있다.   

1. **`CalculateDiscountService`만을 테스트하기 어렵다. :**   
   `CalculateDiscountService`를 테스트하려면 `RuleEngine`이 완벽하게 동작해야한다.    
   즉, **`RuleEngine`을 설정 파일을 만든후에야 정상적인 테스트가 가능하다**는 점이다.  
2. **변경이 어렵다.**    
   ```java
        MutableMoney money = new MutableMoney(0);
        List<?> facts = Arrays.asList(customer, money);
        facts.addAll(orderLines);
        ruleEngine.evaluate("discountCalculation", facts);
   ```
   이 코드들은 `Drools`에 특화된 코드로, **변경이 있을 경우 현재 클래스에도 영향이 간다.** 는 의미다. 
   여기서는 `Drools`의 세션 이름 `discountCalculation`에 대한 종속적인 코드를 작성해서   
   `Drools`의 세션 이름이 변경되면 `CalculateDiscountService`의 코드도 변경해야한다.      
   (MutableMoney 같은 경우 결과값을 보기위해 추가된 타입인데 다른 방식 사용시 필요없을 수 있다.)  
     
이처럼 `CalculateDiscountService`가      
겉으로는 `인프라스트럭처`의 기술에 직접적인 의존을 하지 않는 것처럼 보여도         
실제로는 `인프라스트럭처` 영역의 기술에 완전히 의존하고 있으며          
이런 상황에서 `Drools`가 아닌 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야한다.     

정리하자면, **인프라스트럭처에 의존하면 `테스트 어려움`과 `기능 확장의 어려움`이라는 문제가 발생한다.**   
 
**그렇다면 우리는 `Repository`를 주로 사용하는데 무슨차이가 있는걸까? 🤔**       

## DIP       
`CalculateDiscountService`는 **의미있는 단일 기능을 제공하는 `고수준 모듈`이다.**(가격 할인 계산)         
`고수준 모듈`의 기능을 구현하려면 **여러 하위 기능이 필요하다.**    
위 예시를 들면, `고객 정보를 구하기`, `룰 실행`라는 2 가지 하위 기능이 필요하다.     
  
**`저수준 모듈`은 하위 기능을 실제로 구현한 것이다.**        
`JPA`를 이용해서 고객 정보를읽어오는 모듈과     
`Drools`로 룰을 실행하는 모듈이 저수준 모듈이 된다.     

`고수준 모듈`이 제대로 동작하려면 `저수준 모듈`을 사용해야한다.   
그런데, `고수준 모듈`들이 `저수준 모듈`을 사용하면 **`테스트 어려움`과 `기능 확장의 어려움`이라는 문제가 발생한다.**     
이를 해결하기 위해서 우리는 **추상화한 인터페이스를 사용하면 된다.**    









